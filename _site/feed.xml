<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-08-10T22:02:02-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Troy‚Äôs Website</title><subtitle>I do cool stuff here!</subtitle><entry><title type="html">DC Biasing in Ceramic Capacitors</title><link href="http://localhost:4000/blog/2020/08/09/DC-Biasing-in-Ceramic-Capacitors/" rel="alternate" type="text/html" title="DC Biasing in Ceramic Capacitors" /><published>2020-08-09T12:30:00-04:00</published><updated>2020-08-09T12:30:00-04:00</updated><id>http://localhost:4000/blog/2020/08/09/DC-Biasing-in-Ceramic-Capacitors</id><content type="html" xml:base="http://localhost:4000/blog/2020/08/09/DC-Biasing-in-Ceramic-Capacitors/">&lt;p&gt;When selecting capacitors to use in a board design, multilayer ceramic chip capacitors (MLCCs) are often a good choice. These non-polarized caps are available in relatively high capacitance values and for a cheap price. Their non-polarity can make them more suitable for AC applications, as opposed to their electrolytic brethren. They also tend to have a &lt;em&gt;much&lt;/em&gt; longer shelf-life. However, there are drawbacks to many ceramic capacitors that you will have to consider before soldering them to your board and calling it a day.&lt;/p&gt;

&lt;p&gt;MLCCs are divided into classes based on trade-offs between their stability under different operating conditions and their volumetric efficiency. This is a bit of an oversimplification, but the general idea is that ceramics that offer very high stability in their capacitance over a range of temperatures and voltages require a dialectric material that does not permit large capacitance in a small package (Class I). Conversely, ceramics that use a dialectric that does allow for higher capacitancies will probably not be as stable accross those same temperature and voltage ranges (Class II). Again, the specifics of this are much more complex and nuanced than the few sentences I have spent explaining it. As always, if you want a deep dive into the history, physics, and nomenclature, the wikipedia article on the &lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Ceramic_capacitor&quot;&gt;Ceramic Capacitor&lt;/a&gt;&lt;/strong&gt; is an interesting read.&lt;/p&gt;

&lt;p&gt;In this post however, I specifically want to explore the experimental relationship between the DC voltage bias and capacitance while using caps that utilize an X7R dialectric. This type of dialectric is very common and falls under Class II in the categorization of ceramic caps. As we will soon see, some of these ceramic capacitors have quite a high voltage rating. To the unaware engineer (me), they might assume that this voltage rating signifies a threshold beyond which the capacitor will fail. While this may be true, the reality is that depending on the construction of the component, we may start to see unwanted behavior well before this threshold. And, depending on the sensitivity of our application, this behavour may be catastrophic to our circuit. The results of this experiment should show that going to digikey and selecting a 2.2uF ceramic cap may not be as cut and dry as you might believe.&lt;/p&gt;

&lt;p&gt;For our setup, I have created a simple RC circuit to subject a ceramic cap to different voltages (Vapp). By placing the probe of my oscilloscope on the capacitor, we should be able to measure the time constant displayed by the circuit as it charges. This will allow us to calculate the experimental capacitance exhibited by the MLCC. I will be using a 10k resistor to charge the capacitor, and a pushbutton to discharge the circuit so that we can measure the charging ramp again. When discharging the circuit, I press the push-button in order to short the two leads of the capacitor. I have also set up my oscilloscope to trigger on the rising edge. The simple circuit is shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/dc-biasing-in-ceramic-capacitors-01.png&quot; alt=&quot;DC Biasing in Ceramic Capacitors Experiment Schematic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The capacitors that I am using are rated for 50V. I would have liked to test them over their complete range, but for today I can only test them up to 30V. Even though this does not cover their supposed capability, we should still be able to clearly see the trend I am trying to highlight.&lt;/p&gt;

&lt;p&gt;So as I am sure you know, the time constant of an RC circuit is represented as:&lt;/p&gt;

&lt;p&gt;ùúè = R * C&lt;/p&gt;

&lt;p&gt;Since we are measuring the rise time of our circuit, this ùúè value is also equal to the period of time it takes for the capacitor to charge from zero volts to 63.2% of the applied voltage (Vapp). I will actually be measuring the time it takes to charge from 20% of Vapp up to 63.2% of the remaining voltage rise. For example, for a Vapp of 5V, I would like the start of my interval at 1V. And since 63.2% of the remaining voltage rise between 1V and Vapp is 2.528V, the end of my interval will be at 3.528V.&lt;/p&gt;

&lt;p&gt;Vend = .632 * (Vapp - Vstart) + Vstart&lt;/p&gt;

&lt;p&gt;Having measured the value of ùúè in the circuit, we can use the original equation for the time constant and the resistor value to find the capacitance. Hopefully it will always be 2.2uF? Let‚Äôs find out.&lt;/p&gt;

&lt;p&gt;This table shows the voltage rise over which I am measuring the time constant. I calculate the experimental capacitance as well, using the measured resistance R = 9.77kOhms.&lt;/p&gt;
&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Vapp&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Vstart&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Vend&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ùúè&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Cexp&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.528V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;21.8ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.17uF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7.056V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;21.7ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2.16uF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10.584V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;19.6ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.95uF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14.112V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;15.8ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.57uF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;25V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;17.640V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13.6ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.35uF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;30V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;21.168V&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10.8ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.08uF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;I captured a few of the rise times on the oscilloscope. In order to get the cursors of oscilloscope as close as possible, I did have to change the scale of the axis between captures, so I apologize for the misleading discrepencies. However, the cursor data in the righthand portion of the screenshot shows the information we care about. That would be deltaX giving our measured ùúè value and the Y1 and Y2 values showing our start and stop voltages.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/dc-biasing-in-ceramic-capacitors-02.png&quot; alt=&quot;Rise time of capacitor with DC bias of 5V&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/dc-biasing-in-ceramic-capacitors-03.png&quot; alt=&quot;Rise time of capacitor with DC bias of 20V&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/dc-biasing-in-ceramic-capacitors-04.png&quot; alt=&quot;Rise time of capacitor with DC bias of 30V&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see from the waveforms, the rise time of the 30V bias is significantly quicker than that of the 5V bias. I have also put the results in graph form:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/dc-biasing-in-ceramic-capacitors-05.png&quot; alt=&quot;Experimental Capacitance vs DC Bias&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And here is the final graph showing the percentage of the ideal capacitance that is actually present at different bias voltages.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/dc-biasing-in-ceramic-capacitors-06.png&quot; alt=&quot;Percentage of Ideal Capacitance vs DC Bias&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I have done this experiment a few times with multiple capacitors, but this data is only for a single one. The trend seems to be about the same for me with any cap I choose. Since I am not taking data points from many many trials and averaging them all, this data is far from conclusive. Luckily, there are researchers and companies who have written extensively on this. If you‚Äôd like to read a more, I found this post by KEMET that explains things in a bit more detail: &lt;a href=&quot;https://ec.kemet.com/blog/mlcc-dielectric-differences/&quot;&gt;https://ec.kemet.com/blog/mlcc-dielectric-differences/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Send me an email at &lt;a href=&quot;mailto:posts@troypallay.com&quot;&gt;posts@troypallay.com&lt;/a&gt; if you learned something in this post. Also please let me know if you find something incorrect!&lt;/p&gt;

&lt;p&gt;-Troy&lt;/p&gt;</content><author><name>Troy Pallay</name></author><summary type="html">When selecting capacitors to use in a board design, multilayer ceramic chip capacitors (MLCCs) are often a good choice. These non-polarized caps are available in relatively high capacitance values and for a cheap price. Their non-polarity can make them more suitable for AC applications, as opposed to their electrolytic brethren. They also tend to have a much longer shelf-life. However, there are drawbacks to many ceramic capacitors that you will have to consider before soldering them to your board and calling it a day. MLCCs are divided into classes based on trade-offs between their stability under different operating conditions and their volumetric efficiency. This is a bit of an oversimplification, but the general idea is that ceramics that offer very high stability in their capacitance over a range of temperatures and voltages require a dialectric material that does not permit large capacitance in a small package (Class I). Conversely, ceramics that use a dialectric that does allow for higher capacitancies will probably not be as stable accross those same temperature and voltage ranges (Class II). Again, the specifics of this are much more complex and nuanced than the few sentences I have spent explaining it. As always, if you want a deep dive into the history, physics, and nomenclature, the wikipedia article on the Ceramic Capacitor is an interesting read. In this post however, I specifically want to explore the experimental relationship between the DC voltage bias and capacitance while using caps that utilize an X7R dialectric. This type of dialectric is very common and falls under Class II in the categorization of ceramic caps. As we will soon see, some of these ceramic capacitors have quite a high voltage rating. To the unaware engineer (me), they might assume that this voltage rating signifies a threshold beyond which the capacitor will fail. While this may be true, the reality is that depending on the construction of the component, we may start to see unwanted behavior well before this threshold. And, depending on the sensitivity of our application, this behavour may be catastrophic to our circuit. The results of this experiment should show that going to digikey and selecting a 2.2uF ceramic cap may not be as cut and dry as you might believe. For our setup, I have created a simple RC circuit to subject a ceramic cap to different voltages (Vapp). By placing the probe of my oscilloscope on the capacitor, we should be able to measure the time constant displayed by the circuit as it charges. This will allow us to calculate the experimental capacitance exhibited by the MLCC. I will be using a 10k resistor to charge the capacitor, and a pushbutton to discharge the circuit so that we can measure the charging ramp again. When discharging the circuit, I press the push-button in order to short the two leads of the capacitor. I have also set up my oscilloscope to trigger on the rising edge. The simple circuit is shown below: The capacitors that I am using are rated for 50V. I would have liked to test them over their complete range, but for today I can only test them up to 30V. Even though this does not cover their supposed capability, we should still be able to clearly see the trend I am trying to highlight. So as I am sure you know, the time constant of an RC circuit is represented as: ùúè = R * C Since we are measuring the rise time of our circuit, this ùúè value is also equal to the period of time it takes for the capacitor to charge from zero volts to 63.2% of the applied voltage (Vapp). I will actually be measuring the time it takes to charge from 20% of Vapp up to 63.2% of the remaining voltage rise. For example, for a Vapp of 5V, I would like the start of my interval at 1V. And since 63.2% of the remaining voltage rise between 1V and Vapp is 2.528V, the end of my interval will be at 3.528V. Vend = .632 * (Vapp - Vstart) + Vstart Having measured the value of ùúè in the circuit, we can use the original equation for the time constant and the resistor value to find the capacitance. Hopefully it will always be 2.2uF? Let‚Äôs find out. This table shows the voltage rise over which I am measuring the time constant. I calculate the experimental capacitance as well, using the measured resistance R = 9.77kOhms. Vapp Vstart Vend ùúè Cexp 5V 1V 3.528V 21.8ms 2.17uF 10V 2V 7.056V 21.7ms 2.16uF 15V 3V 10.584V 19.6ms 1.95uF 20V 4V 14.112V 15.8ms 1.57uF 25V 5V 17.640V 13.6ms 1.35uF 30V 6V 21.168V 10.8ms 1.08uF I captured a few of the rise times on the oscilloscope. In order to get the cursors of oscilloscope as close as possible, I did have to change the scale of the axis between captures, so I apologize for the misleading discrepencies. However, the cursor data in the righthand portion of the screenshot shows the information we care about. That would be deltaX giving our measured ùúè value and the Y1 and Y2 values showing our start and stop voltages. As you can see from the waveforms, the rise time of the 30V bias is significantly quicker than that of the 5V bias. I have also put the results in graph form: And here is the final graph showing the percentage of the ideal capacitance that is actually present at different bias voltages. I have done this experiment a few times with multiple capacitors, but this data is only for a single one. The trend seems to be about the same for me with any cap I choose. Since I am not taking data points from many many trials and averaging them all, this data is far from conclusive. Luckily, there are researchers and companies who have written extensively on this. If you‚Äôd like to read a more, I found this post by KEMET that explains things in a bit more detail: https://ec.kemet.com/blog/mlcc-dielectric-differences/. Send me an email at posts@troypallay.com if you learned something in this post. Also please let me know if you find something incorrect! -Troy</summary></entry><entry><title type="html">LED Matrices</title><link href="http://localhost:4000/blog/2020/07/12/LED-Matrices/" rel="alternate" type="text/html" title="LED Matrices" /><published>2020-07-12T12:23:00-04:00</published><updated>2020-07-12T12:23:00-04:00</updated><id>http://localhost:4000/blog/2020/07/12/LED-Matrices</id><content type="html" xml:base="http://localhost:4000/blog/2020/07/12/LED-Matrices/">&lt;p&gt;&lt;em&gt;This is an old post migrated from my previous site.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Many years ago I attempted to create a circuit that drove a large number of LEDs mounted in a sign. It essentially consisted of an astable multivibrator made of some discrete components and two groups of LEDs in parallel. My goal was to blink these two banks of LEDs so the sign caught the eye. However, I soon realized that my large number of LEDs were taxing the 9V battery I was using with quite the current draw when they were switched on. That meant that my sign could only be powered for a very short time from a mobile source.&lt;/p&gt;

&lt;p&gt;That‚Äôs because I wasn‚Äôt using an individually addressable LED matrix! Apparently, I wasn‚Äôt very bright back then (and neither were my diodes). But not today! I‚Äôm much wiser in my ways, and when we couple Arduino magic with a few blinky bois, we can accomplish some beautiful results.&lt;/p&gt;

&lt;p&gt;So, let‚Äôs get down to brass tacks and check out a circuit diagram to understand just how these savings in current work (shoutout to &lt;a href=&quot;https://easyeda.com&quot;&gt;EasyEDA&lt;/a&gt; for the quick and easy schematic software!).&lt;/p&gt;

&lt;object data=&quot;/assets/posts/led-matrices-01.pdf&quot; width=&quot;100%&quot; height=&quot;500&quot; type=&quot;application/pdf&quot;&gt;
PDF not viewable&lt;/object&gt;

&lt;p&gt;As you can see, I have a very simple setup. For each column shown in the diagram, six LEDs are connected by their cathodes (C[1-6]). For each row, six LEDs are connected by their anodes (A[1-6]). I have also shown the pin on the Arduino to which I have connected each net of either anodes or cathodes. By connecting the LEDs in this way, we have created a matrix. And this is important because it means we can think of each LED in this matrix as having its home at an address. For example, the diode in the top left of the diagram is connected to cathode grouping 1 as well as anode grouping 6. Let‚Äôs think of this component as having an address of (1, 6). In the same way, we can think of the diode in the bottom right (cathode 6 and anode 1) as having an address of (6, 1).&lt;/p&gt;

&lt;p&gt;Well, that‚Äôs all well and good, but what does it really accomplish? Let‚Äôs take a step back and remember how LEDs (light-emitting diodes) really work. The LED in its simplest form is a two-pin component. It has a positive end called the anode and a negative end called the cathode. In order to turn the LED on and produce light, we need to send current into the anode and out through the cathode. And, following the basic principles of electricity, we then know that the anode needs to be at a higher voltage than the cathode in order for current to flow in this direction. This is called a forward-bias. If we do the opposite and connect the cathode to a higher voltage than the anode, we would be subjecting the LED to a reverse-bias. In the case of LEDs, this reverse biasing does nothing. The diode will be off and unlit. In a similar manner, when both the anode and cathode are at the same voltage, the diode is also off because no current is flowing.&lt;/p&gt;

&lt;p&gt;Here‚Äôs a table that summarizes the behavior:&lt;/p&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Anode&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Cathode&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Result&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Anode LOW&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cathode LOW&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OFF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Anode LOW&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cathode HIGH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OFF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Anode HIGH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cathode LOW&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ON&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Anode HIGH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Cathode HIGH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OFF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;Notice there is only a single state where the LED is lit.&lt;/p&gt;

&lt;p&gt;So, back to the problem at hand! Why would we want to address the LEDs with all of these banks of anodes and cathodes? For individual control of course. Let‚Äôs assume our default starting state is to reverse-bias all of the diodes in the matrix. In that case, we would be setting all of the anode banks to logic low (0V) and all of the cathode banks to logic high (5V). Now all of the lights are off. What happens if we flip the logic levels of a single anode bank and a single cathode bank?&lt;/p&gt;

&lt;p&gt;Take anode bank 2 and cathode bank 1. Now all of the LEDs connected to anode bank 2 have their anodes high and all of the LEDs connected to cathode bank 1 have their cathodes low. That means that at the intersection between anode 2 and cathode 1, LED(2, 1) is in the single ‚Äòon‚Äô state and all other LEDs in the matrix are in one of the other three possible ‚Äòoff‚Äô states. Taking this a step further, we can now see that beginning with all of the anodes low and cathodes high, then toggling any anode and cathode, we turn on the LED that is at their intersection.&lt;/p&gt;

&lt;p&gt;If you still can‚Äôt quite picture what is going on, I don‚Äôt blame you. Check out this &lt;a href=&quot;/pages/led-matrix-simulator.html&quot;&gt;interactive javascript app&lt;/a&gt; that I made to further illustrate the behavior. Please excuse the slightly underwhelming graphics‚Ä¶&lt;/p&gt;

&lt;p&gt;The second concept that we should review before actually implementing this topic into a circuit is ‚Äòpersistence of vision‚Äô. I won‚Äôt get into the nitty-gritty of this, but it is a very important phenomenon in relation to lights and displays. The applicable idea in this situation is a simple statement: We can blink an LED at such a high frequency that the human brain perceives it to be simply ‚Äòon‚Äô. It‚Äôs a simple enough idea, but it has big consequences for our matrix. If we can blink a single LED fast enough to make it appear ‚Äòon‚Äô, then that means we can blink an entire matrix of LEDs so that they all appear ‚Äòon‚Äô at the same time. We do this by turning one LED on, then off. Then the next light in the matrix is turned on, then off. And so on and so forth until we have pulsed all of the lights on and off. We continue looping through each diode in the matrix, giving them a pulse. It is done so quickly that all of the LEDs appear to simply be ‚Äòon‚Äô.&lt;/p&gt;

&lt;p&gt;We have two ideas now. The first is that by connecting LEDs in rows and columns by anodes and cathodes, we can produce a circuit that has the capability of driving single LEDs at any given time. The second is that we can pulse a large number of LEDs so quickly that they all appear to be ‚Äòon‚Äô at the same time. Combining these abilities results in a matrix of LEDs that can light in any combo we want! It‚Äôs almost as if we‚Äôve created a very simple monitor or display‚Ä¶ And we have! Old displays used this same idea. The technology is called a passive-matrix control scheme, or PMOLED. In the case of LCD screens, each pixel isn‚Äôt actually creating light. There is a backlight that shines through the colored pixels, and that‚Äôs how we see the display. However, the idea of controlling those individual pixels in a vast array is the same!&lt;/p&gt;

&lt;p&gt;Perfect! Now we have a better understanding of the underlying mechanics of this LED matrix. Let‚Äôs actually implement the idea on the breadboard and hook up the Arduino. I‚Äôve taken the liberty of loading up the code I‚Äôve written to run the matrix through a few paces. But don‚Äôt worry, we‚Äôll soon be going over that.&lt;/p&gt;

&lt;div class=&quot;embed-container&quot;&gt;
  &lt;iframe src=&quot;https://www.youtube.com/embed/4ez2iLf2AL0?feature=oembed&amp;amp;wmode=transparent&quot; width=&quot;100%&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;As you can see in the video, I have six anode banks and six cathode banks. I stopped at six because I was running out of digital IO on that side of the Arduino microcontroller. But with just twelve total signals coming from the Arduino, we already have a matrix comprised of thirty-six LEDs! I tried to wire the breadboard neatly so that you can clearly see all of the LEDs.&lt;/p&gt;

&lt;p&gt;You might also notice that when only single LEDs are lit, they are much brighter than when multiple LEDs are on at one time. This is due to the duty cycle of the LED. When only a single diode is lit, all electrical power is being used by just that diode. But when multiple diodes are lit, they all have to share the power being output over that amount of time. In our case, when a single LED is illuminated, it has a 100% duty cycle. It is simply on. But as we light an entire column or row, we are splitting the ‚Äòon‚Äô time for any single given LED between five others. So each LED is only getting about 16% duty cycle (it‚Äôs only on for 1/6th of the time). As with most things, Wikipedia has an excellent explanation of the concept of &lt;a href=&quot;https://en.wikipedia.org/wiki/Duty_cycle&quot;&gt;duty cycle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But enough of that. It‚Äôs time to dig into the code! &lt;strong&gt;View the entire source on &lt;a href=&quot;https://troypallay.com/wp-content/uploads/2019/10/LEDmatrix.txt&quot;&gt;Github&lt;/a&gt;&lt;/strong&gt;. In the next few sections, I will be explaining the code piece by piece:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define ROW1 8
#define ROW2 9
#define ROW3 10
#define ROW4 11
#define ROW5 12
#define ROW6 13

#define COL1 2
#define COL2 3
#define COL3 4
#define COL4 5
#define COL5 6
#define COL6 7

int ROW[] = { ROW1, ROW2, ROW3, ROW4, ROW5, ROW6 };
int COL[] = { COL1, COL2, COL3, COL4, COL5, COL6 };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The beginning of the file starts with some #define statements. These statements are especially useful in the case of Arduino because they allow us to map names to pin numbers. And that‚Äôs what I‚Äôm doing here. I also create two arrays that hold the numbers of all the pins used as rows (anodes) and columns (cathodes). This is just a time-saving device that will allow me to perform actions on many pins at a time with fewer statements. You‚Äôll see this in the next function.&lt;/p&gt;

&lt;p&gt;From now on, we can go function by function. Peep my setup().&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void setup() {

  for( int i = 0; i &amp;lt; 6; i++ ) {
    digitalWrite( ROW[i], LOW );
    pinMode( ROW[i], OUTPUT );
  }

  for( int i = 0; i &amp;lt; 6; i++ ) {
    digitalWrite( COL[i], HIGH );
    pinMode( COL[i], OUTPUT );
  }

  randomSeed(analogRead(0));

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First I write all of the anode pins low and then set them as output pins. I usually try to write my pins high or low before I actually assert them as outputs just so that I know exactly how they are behaving before sending signals into my circuit. As you can see, since I placed all of the pins in arrays, it is much easier to perform repetitive tasks on all of them in a loop. Next, I write all of the cathode pins high and set them as outputs as well. Finally, I retrieve a random seed from one of the Arduino‚Äôs analog pins. This is another thing that we will use in a later function. It will allow us to generate random numbers when we need them.&lt;/p&gt;

&lt;p&gt;Next up is the LED pulse function.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * Function: led_pulse
 * --------------------
 * Illuminates a chosen LED for a specified amount of time
 *
 * row: row that the LED occupies
 * col: column that the LED occupies
 * t : length of time that the LED will be illuminated in MICROSECONDS
 */
void led_pulse( int row, int col, unsigned long t ) {

  int multiple = t / 16383;
  int r = t % 16383;
  if( t &amp;gt; 16383 ) t = 16383;

  digitalWrite( ROW[row - 1], HIGH );
  digitalWrite( COL[col - 1], LOW );

  while( multiple ) {
    delayMicroseconds( t );
    multiple--;
  }
  delayMicroseconds( r );

  digitalWrite( ROW[row - 1], LOW );
  digitalWrite( COL[col - 1], HIGH );

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is probably the most complicated looking function in the whole sketch, but even then, it‚Äôs really pretty simple. To start off, the function is taking in three arguments: row, col, and t. row and col are self-explanatory. They refer to the row and column (or the address) at which you want to light an LED. Lastly, t is how long the LED will be illuminated in microseconds. The reason why we want to be able to specify the length of time that the LED is lit in such small increments is that when we illuminate a large bank of LEDs, they will need to all be blinking very rapidly to create the persistence of vision effect. We want to turn the LED on, wait a very short period, then turn it off. To create these short time delays, we use the delayMicroseconds() function. It takes an unsigned integer value for how many microseconds of delay you need. However, we have a problem. The Arduino reference material states that 16383 is the largest value that should be given to this function (see here). Beyond that, the function may not reliably work. This creates a problem for us because it means that the longest delay we can reliably produce is only 0.016383 seconds!!! Sure, we want fast blinking to make it appear as though many LEDs are lit at once, but what if we want to only light one LED for a long period? We could repeatedly call this function many times in a row, but I‚Äôd like to make it so that we can specify much longer periods of time without calling led_pulse() hundreds of times.&lt;/p&gt;

&lt;p&gt;My solution to this is as follows: We take in the number t. We also create two variables multiple and r. multiple becomes t divided by the max value 16383 so that we know how many times we need to call the delay function with that max value to add up to a total delay of t. However, since we are dealing with integer division, we should also catch the remainder of this operation so that we stay accurate to the requested t delay. If you are not familiar with the mathematical operator to do this, it is called modulo. It is related to the division operator, but instead of giving us the quotient, it gives us the remainder. We end up with the situation described below:&lt;/p&gt;

&lt;p&gt;requested t = (multiple * 16383) + r&lt;/p&gt;

&lt;p&gt;If the requested t value is less than the max value, multiple will be 0 and r will be equal to t. If the requested t value was greater than the max value, then multiple will be a positive integer and r will be the positive remainder value. However, in that situation, we should also set t to the max value so that the delay function is not called with a number that is too large. We no longer need t to represent the requested t value because using the above function, we can now recover it using multiple and the max value 16383.&lt;/p&gt;

&lt;p&gt;Beginning on line 16 of the snippet we then write the row high and the column low. Using ROW[row ‚Äì 1] allows the input of the function row to be a row number 1 through 6. subtracting one from that number and using it as the index of our ROW[] matrix translates it into the number corresponding with that row‚Äôs pin. The same is done with the column to write it low. Now we wait‚Ä¶ Using the values that we calculated earlier, we use the delayMicroseconds() function to wait for the proper amount of time. If the requested time was less than the max value, we wait for r microseconds (which would be equal to t). If the requested value was greater than the maximum allowed value, we loop multiple times, each time waiting for the maximum number of microseconds. After the loop is exhausted, we then complete the waiting period with r microseconds to ensure the total requested time was observed. Now that we have waited for the proper amount of time, the LED is turned off by asserting the row low and the column high.&lt;/p&gt;

&lt;p&gt;As an aside, notice that we use an unsigned long data type for the t argument. since we are treating this as the number of microseconds, that means that the largest argument we can pass is 4,294,967,295 (32 bits or 2^32 ‚Äì 1). That many microseconds convert to about 70 minutes.&lt;/p&gt;

&lt;p&gt;Now let‚Äôs pulse rows and columns of LEDs all at one time!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * Function: row_pulse
 * --------------------
 * Illuminates a chosen row of LEDs for a specified amount of time
 *
 * row: row to be illuminated
 * row_t: length of time that the row will be illuminated in MILLISECONDS
 */
void row_pulse( int row, unsigned long row_t ) {

  unsigned long start = millis();
  while( millis() - start &amp;lt; row_t ) {

    for( int col = 1; col &amp;lt; 7; col++) led_pulse( row, col, 10 );

  }

}

/*
 * Function: col_pulse
 * --------------------
 * Illuminates a chosen column of LEDs for a specified amount of time
 *
 * col: column to be illuminated
 * col_t: length of time that the column will be illuminated in MILLISECONDS
 */
void col_pulse( int col, unsigned long col_t ) {

  unsigned long start = millis();
  while( millis() - start &amp;lt; col_t ) {

    for( int row = 1; row &amp;lt; 7; row++) led_pulse( row, col, 10 );

  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These two functions operate by making use of the led_pulse() function. Each function takes either a row or col, as well as a time value. Notice that it is in milliseconds and not microseconds. This time value will specify how long each row or column is lit. A different method for keeping track of this time is shown here. Instead of using specific time delays that add up to the total requested period, the current time in milliseconds is recorded at the beginning of the function call. Then, the current time is repeatedly called until the correct amount of time has passed. At that point, the function exits.&lt;/p&gt;

&lt;p&gt;In order to actually light an entire row or column, a for loop is used. In the row_pulse() function, led_pulse() is used with a constant row value, but an incrementing col value. This means that by using a small value like 10 microseconds, all of the LEDs in a row appear lit. The same principle is used in col_pulse(). And, since we are running through six LEDs at a time, this means we are checking the current time against the requested time every 60 microseconds because that is how long it takes to fully run through the loop.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * Function: all_on
 * --------------------
 * Illuminates all LEDs in the matrix for a specified amount of time
 *
 * all_t: length of time that all LEDs will be illuminated in MILLISECONDS
 */
void all_on( unsigned long all_t ) {

  unsigned long start = millis();
  int flag = 1;
  while( flag ) {

    for( int row = 1; row &amp;lt; 7; row++) {
      for( int col = 1; col &amp;lt; 7; col++) {
        led_pulse( row, col, 20 );
        if( millis() - start &amp;gt; all_t ) flag = 0;
      }
    }

  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The all_on() function behaves exactly as named. It illuminates all of the LEDs in the 6√ó6 matrix for a specified amount of time. Again, this function takes its argument in milliseconds. And there is yet again a different method for keeping track of time. This one is quite similar to the previous method in that it checks the runtime of the method against the requested time. But, in this case, the check is performed after every single pulse of a single LED. To do this, a flag integer is used to check that the runtime is still less than the requested time. All of the LED pulsing happens within a while loop, so when the correct amount of time has elapsed, the flag is simply set to 0, or false, and the while loop exits along with the function. And, in order to flash all LEDs in the matrix one after another, two for loops run through each row and each column, lighting all the LEDs along the way. This time, 20 microseconds is used as the ‚Äòon‚Äô time for led_pulse().&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * Function: zig_rows
 * --------------------
 * Illuminates rows one by one, in a back and forth pattern.
 *    This starts with row 1, progreses to row 6, then ends back at row 2
 *
 * repeat: number of times that the pattern will be repeated
 * row_t: length of time that each individual row will be illuminated in MILLISECONDS
 */
void zig_rows( int repeat, unsigned long row_t ) {

  while( repeat ) {

    for( unsigned long i = 2345654321; i &amp;gt; 0; i = i / 10 )
      row_pulse( i % 10, row_t );

    repeat--;
  }

}

/*
 * Function: zig_cols
 * --------------------
 * Illuminates columns one by one, in a back and forth pattern.
 *    This starts with column 1, progreses to column 6, then ends back at column 2
 *
 * repeat: number of times that the pattern will be repeated
 * col_t: length of time that each individual column will be illuminated in MILLISECONDS
 */
void zig_cols( int repeat, unsigned long col_t ) {

  while( repeat ) {

    for( unsigned long i = 2345654321; i &amp;gt; 0; i = i / 10 )
      col_pulse( i % 10, col_t );

    repeat--;
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I like these functions quite a lot. They are for creating a certain pattern using the row and column pulse functions. The for loop might look a little strange, but it‚Äôs nothing crazy. I start with a counter integer 2345654321. On the first pass of the loop, either row or col_pulse is called. If we take zig_rows(), for example, the row that is called is i % 10. By using modulo ten, we are calculating the remainder of a number divided by ten. And anything divided by ten gives a remainder of whatever was in that number‚Äôs one‚Äôs place. This means that the row that is pulsed corresponds to the one‚Äôs place of our counter integer i. On the first pass, it would be 1, since 1 is in the one‚Äôs place of 2345654321. Our loop then divides the counter by 10. Since it is integer division, this just chops off the current digit in the one‚Äôs place. The counter is now 234565432. This repeats until i is divided away to 0, meaning that each row is called in a back and forth pattern (rows 1, 2, 3, 4, 5, 6, then 5, 4, 3, and finally 2 again). You‚Äôll also note that the counter i is of the data type unsigned long. That‚Äôs because it is such a large number, we need a large data type to hold it.&lt;/p&gt;

&lt;p&gt;This entire process is enclosed in a while loop that also has a counter that is decrementing. It uses the repeat argument that is passed to the function in order to loop the pattern for the requested number of times. The function also takes an argument that it uses in either the col_pulse() or row_pulse() function for the length of time each row or column should be lit for. Note that this value is in milliseconds.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * Function: led_rand
 * --------------------
 * Illuminates a specified number of random LEDs in the matrix, each for a specified amount of time
 *
 * repeat: number of LEDs to be illuminated, one after another
 * t: length of time that the random LED will be illuminated in MILLISECONDS
 */
void led_rand( int repeat, unsigned long t ) {

  while( repeat ) {
    led_pulse( random( 1, 7 ), random( 1, 7 ), t * 1000 );
    repeat--;
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is my favorite function. It makes use of the random seed that we created earlier in order to flash a random LED in the matrix. Its arguments are repeat and t. Just like the last two functions, repeat is how many times the pattern should repeat. And in this case, the pattern is just picking a random LED to pulse. t is how long each random LED should be illuminated. Notice that this function also takes its time argument in milliseconds. However, the led_pulse() function takes its time in microseconds. In order to convert, we simply multiply by 1000 before calling led_pulse().&lt;/p&gt;

&lt;p&gt;In order to pick a random LED, random() is used with two arguments. 1 is given as a minimum value (inclusive), and 7 is given as a maximum value (exclusive).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void loop() {

  zig_rows( 2, 200 );
  all_on( 500 );

  led_rand( 20, 200 );
  all_on( 500 );

  zig_cols( 2, 200 );
  all_on( 500 );

  led_rand( 20, 200 );
  all_on( 500 );

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, we finish up with the actual Arduino loop() function! All it consists of is calling some of our created functions with appropriate values. Play around with these values to see how it changes the patterns and timings! You could also change the ‚Äòon‚Äô time values in the row_pulse(), col_pulse(), and all_on() functions in order to experiment with different values than 10 and 20 microseconds when calling led_pulse(). Have fun!&lt;/p&gt;

&lt;p&gt;-Troy&lt;/p&gt;</content><author><name>Troy Pallay</name></author><summary type="html">This is an old post migrated from my previous site. Many years ago I attempted to create a circuit that drove a large number of LEDs mounted in a sign. It essentially consisted of an astable multivibrator made of some discrete components and two groups of LEDs in parallel. My goal was to blink these two banks of LEDs so the sign caught the eye. However, I soon realized that my large number of LEDs were taxing the 9V battery I was using with quite the current draw when they were switched on. That meant that my sign could only be powered for a very short time from a mobile source. That‚Äôs because I wasn‚Äôt using an individually addressable LED matrix! Apparently, I wasn‚Äôt very bright back then (and neither were my diodes). But not today! I‚Äôm much wiser in my ways, and when we couple Arduino magic with a few blinky bois, we can accomplish some beautiful results. So, let‚Äôs get down to brass tacks and check out a circuit diagram to understand just how these savings in current work (shoutout to EasyEDA for the quick and easy schematic software!). PDF not viewable As you can see, I have a very simple setup. For each column shown in the diagram, six LEDs are connected by their cathodes (C[1-6]). For each row, six LEDs are connected by their anodes (A[1-6]). I have also shown the pin on the Arduino to which I have connected each net of either anodes or cathodes. By connecting the LEDs in this way, we have created a matrix. And this is important because it means we can think of each LED in this matrix as having its home at an address. For example, the diode in the top left of the diagram is connected to cathode grouping 1 as well as anode grouping 6. Let‚Äôs think of this component as having an address of (1, 6). In the same way, we can think of the diode in the bottom right (cathode 6 and anode 1) as having an address of (6, 1). Well, that‚Äôs all well and good, but what does it really accomplish? Let‚Äôs take a step back and remember how LEDs (light-emitting diodes) really work. The LED in its simplest form is a two-pin component. It has a positive end called the anode and a negative end called the cathode. In order to turn the LED on and produce light, we need to send current into the anode and out through the cathode. And, following the basic principles of electricity, we then know that the anode needs to be at a higher voltage than the cathode in order for current to flow in this direction. This is called a forward-bias. If we do the opposite and connect the cathode to a higher voltage than the anode, we would be subjecting the LED to a reverse-bias. In the case of LEDs, this reverse biasing does nothing. The diode will be off and unlit. In a similar manner, when both the anode and cathode are at the same voltage, the diode is also off because no current is flowing. Here‚Äôs a table that summarizes the behavior: Anode Cathode Result Anode LOW Cathode LOW OFF Anode LOW Cathode HIGH OFF Anode HIGH Cathode LOW ON Anode HIGH Cathode HIGH OFF Notice there is only a single state where the LED is lit. So, back to the problem at hand! Why would we want to address the LEDs with all of these banks of anodes and cathodes? For individual control of course. Let‚Äôs assume our default starting state is to reverse-bias all of the diodes in the matrix. In that case, we would be setting all of the anode banks to logic low (0V) and all of the cathode banks to logic high (5V). Now all of the lights are off. What happens if we flip the logic levels of a single anode bank and a single cathode bank? Take anode bank 2 and cathode bank 1. Now all of the LEDs connected to anode bank 2 have their anodes high and all of the LEDs connected to cathode bank 1 have their cathodes low. That means that at the intersection between anode 2 and cathode 1, LED(2, 1) is in the single ‚Äòon‚Äô state and all other LEDs in the matrix are in one of the other three possible ‚Äòoff‚Äô states. Taking this a step further, we can now see that beginning with all of the anodes low and cathodes high, then toggling any anode and cathode, we turn on the LED that is at their intersection. If you still can‚Äôt quite picture what is going on, I don‚Äôt blame you. Check out this interactive javascript app that I made to further illustrate the behavior. Please excuse the slightly underwhelming graphics‚Ä¶ The second concept that we should review before actually implementing this topic into a circuit is ‚Äòpersistence of vision‚Äô. I won‚Äôt get into the nitty-gritty of this, but it is a very important phenomenon in relation to lights and displays. The applicable idea in this situation is a simple statement: We can blink an LED at such a high frequency that the human brain perceives it to be simply ‚Äòon‚Äô. It‚Äôs a simple enough idea, but it has big consequences for our matrix. If we can blink a single LED fast enough to make it appear ‚Äòon‚Äô, then that means we can blink an entire matrix of LEDs so that they all appear ‚Äòon‚Äô at the same time. We do this by turning one LED on, then off. Then the next light in the matrix is turned on, then off. And so on and so forth until we have pulsed all of the lights on and off. We continue looping through each diode in the matrix, giving them a pulse. It is done so quickly that all of the LEDs appear to simply be ‚Äòon‚Äô. We have two ideas now. The first is that by connecting LEDs in rows and columns by anodes and cathodes, we can produce a circuit that has the capability of driving single LEDs at any given time. The second is that we can pulse a large number of LEDs so quickly that they all appear to be ‚Äòon‚Äô at the same time. Combining these abilities results in a matrix of LEDs that can light in any combo we want! It‚Äôs almost as if we‚Äôve created a very simple monitor or display‚Ä¶ And we have! Old displays used this same idea. The technology is called a passive-matrix control scheme, or PMOLED. In the case of LCD screens, each pixel isn‚Äôt actually creating light. There is a backlight that shines through the colored pixels, and that‚Äôs how we see the display. However, the idea of controlling those individual pixels in a vast array is the same! Perfect! Now we have a better understanding of the underlying mechanics of this LED matrix. Let‚Äôs actually implement the idea on the breadboard and hook up the Arduino. I‚Äôve taken the liberty of loading up the code I‚Äôve written to run the matrix through a few paces. But don‚Äôt worry, we‚Äôll soon be going over that. As you can see in the video, I have six anode banks and six cathode banks. I stopped at six because I was running out of digital IO on that side of the Arduino microcontroller. But with just twelve total signals coming from the Arduino, we already have a matrix comprised of thirty-six LEDs! I tried to wire the breadboard neatly so that you can clearly see all of the LEDs. You might also notice that when only single LEDs are lit, they are much brighter than when multiple LEDs are on at one time. This is due to the duty cycle of the LED. When only a single diode is lit, all electrical power is being used by just that diode. But when multiple diodes are lit, they all have to share the power being output over that amount of time. In our case, when a single LED is illuminated, it has a 100% duty cycle. It is simply on. But as we light an entire column or row, we are splitting the ‚Äòon‚Äô time for any single given LED between five others. So each LED is only getting about 16% duty cycle (it‚Äôs only on for 1/6th of the time). As with most things, Wikipedia has an excellent explanation of the concept of duty cycle. But enough of that. It‚Äôs time to dig into the code! View the entire source on Github. In the next few sections, I will be explaining the code piece by piece: #define ROW1 8 #define ROW2 9 #define ROW3 10 #define ROW4 11 #define ROW5 12 #define ROW6 13 #define COL1 2 #define COL2 3 #define COL3 4 #define COL4 5 #define COL5 6 #define COL6 7 int ROW[] = { ROW1, ROW2, ROW3, ROW4, ROW5, ROW6 }; int COL[] = { COL1, COL2, COL3, COL4, COL5, COL6 }; The beginning of the file starts with some #define statements. These statements are especially useful in the case of Arduino because they allow us to map names to pin numbers. And that‚Äôs what I‚Äôm doing here. I also create two arrays that hold the numbers of all the pins used as rows (anodes) and columns (cathodes). This is just a time-saving device that will allow me to perform actions on many pins at a time with fewer statements. You‚Äôll see this in the next function. From now on, we can go function by function. Peep my setup(). void setup() { for( int i = 0; i &amp;lt; 6; i++ ) { digitalWrite( ROW[i], LOW ); pinMode( ROW[i], OUTPUT ); } for( int i = 0; i &amp;lt; 6; i++ ) { digitalWrite( COL[i], HIGH ); pinMode( COL[i], OUTPUT ); } randomSeed(analogRead(0)); } First I write all of the anode pins low and then set them as output pins. I usually try to write my pins high or low before I actually assert them as outputs just so that I know exactly how they are behaving before sending signals into my circuit. As you can see, since I placed all of the pins in arrays, it is much easier to perform repetitive tasks on all of them in a loop. Next, I write all of the cathode pins high and set them as outputs as well. Finally, I retrieve a random seed from one of the Arduino‚Äôs analog pins. This is another thing that we will use in a later function. It will allow us to generate random numbers when we need them. Next up is the LED pulse function. /* * Function: led_pulse * -------------------- * Illuminates a chosen LED for a specified amount of time * * row: row that the LED occupies * col: column that the LED occupies * t : length of time that the LED will be illuminated in MICROSECONDS */ void led_pulse( int row, int col, unsigned long t ) { int multiple = t / 16383; int r = t % 16383; if( t &amp;gt; 16383 ) t = 16383; digitalWrite( ROW[row - 1], HIGH ); digitalWrite( COL[col - 1], LOW ); while( multiple ) { delayMicroseconds( t ); multiple--; } delayMicroseconds( r ); digitalWrite( ROW[row - 1], LOW ); digitalWrite( COL[col - 1], HIGH ); } This is probably the most complicated looking function in the whole sketch, but even then, it‚Äôs really pretty simple. To start off, the function is taking in three arguments: row, col, and t. row and col are self-explanatory. They refer to the row and column (or the address) at which you want to light an LED. Lastly, t is how long the LED will be illuminated in microseconds. The reason why we want to be able to specify the length of time that the LED is lit in such small increments is that when we illuminate a large bank of LEDs, they will need to all be blinking very rapidly to create the persistence of vision effect. We want to turn the LED on, wait a very short period, then turn it off. To create these short time delays, we use the delayMicroseconds() function. It takes an unsigned integer value for how many microseconds of delay you need. However, we have a problem. The Arduino reference material states that 16383 is the largest value that should be given to this function (see here). Beyond that, the function may not reliably work. This creates a problem for us because it means that the longest delay we can reliably produce is only 0.016383 seconds!!! Sure, we want fast blinking to make it appear as though many LEDs are lit at once, but what if we want to only light one LED for a long period? We could repeatedly call this function many times in a row, but I‚Äôd like to make it so that we can specify much longer periods of time without calling led_pulse() hundreds of times. My solution to this is as follows: We take in the number t. We also create two variables multiple and r. multiple becomes t divided by the max value 16383 so that we know how many times we need to call the delay function with that max value to add up to a total delay of t. However, since we are dealing with integer division, we should also catch the remainder of this operation so that we stay accurate to the requested t delay. If you are not familiar with the mathematical operator to do this, it is called modulo. It is related to the division operator, but instead of giving us the quotient, it gives us the remainder. We end up with the situation described below: requested t = (multiple * 16383) + r If the requested t value is less than the max value, multiple will be 0 and r will be equal to t. If the requested t value was greater than the max value, then multiple will be a positive integer and r will be the positive remainder value. However, in that situation, we should also set t to the max value so that the delay function is not called with a number that is too large. We no longer need t to represent the requested t value because using the above function, we can now recover it using multiple and the max value 16383. Beginning on line 16 of the snippet we then write the row high and the column low. Using ROW[row ‚Äì 1] allows the input of the function row to be a row number 1 through 6. subtracting one from that number and using it as the index of our ROW[] matrix translates it into the number corresponding with that row‚Äôs pin. The same is done with the column to write it low. Now we wait‚Ä¶ Using the values that we calculated earlier, we use the delayMicroseconds() function to wait for the proper amount of time. If the requested time was less than the max value, we wait for r microseconds (which would be equal to t). If the requested value was greater than the maximum allowed value, we loop multiple times, each time waiting for the maximum number of microseconds. After the loop is exhausted, we then complete the waiting period with r microseconds to ensure the total requested time was observed. Now that we have waited for the proper amount of time, the LED is turned off by asserting the row low and the column high. As an aside, notice that we use an unsigned long data type for the t argument. since we are treating this as the number of microseconds, that means that the largest argument we can pass is 4,294,967,295 (32 bits or 2^32 ‚Äì 1). That many microseconds convert to about 70 minutes. Now let‚Äôs pulse rows and columns of LEDs all at one time! /* * Function: row_pulse * -------------------- * Illuminates a chosen row of LEDs for a specified amount of time * * row: row to be illuminated * row_t: length of time that the row will be illuminated in MILLISECONDS */ void row_pulse( int row, unsigned long row_t ) { unsigned long start = millis(); while( millis() - start &amp;lt; row_t ) { for( int col = 1; col &amp;lt; 7; col++) led_pulse( row, col, 10 ); } } /* * Function: col_pulse * -------------------- * Illuminates a chosen column of LEDs for a specified amount of time * * col: column to be illuminated * col_t: length of time that the column will be illuminated in MILLISECONDS */ void col_pulse( int col, unsigned long col_t ) { unsigned long start = millis(); while( millis() - start &amp;lt; col_t ) { for( int row = 1; row &amp;lt; 7; row++) led_pulse( row, col, 10 ); } } These two functions operate by making use of the led_pulse() function. Each function takes either a row or col, as well as a time value. Notice that it is in milliseconds and not microseconds. This time value will specify how long each row or column is lit. A different method for keeping track of this time is shown here. Instead of using specific time delays that add up to the total requested period, the current time in milliseconds is recorded at the beginning of the function call. Then, the current time is repeatedly called until the correct amount of time has passed. At that point, the function exits. In order to actually light an entire row or column, a for loop is used. In the row_pulse() function, led_pulse() is used with a constant row value, but an incrementing col value. This means that by using a small value like 10 microseconds, all of the LEDs in a row appear lit. The same principle is used in col_pulse(). And, since we are running through six LEDs at a time, this means we are checking the current time against the requested time every 60 microseconds because that is how long it takes to fully run through the loop. /* * Function: all_on * -------------------- * Illuminates all LEDs in the matrix for a specified amount of time * * all_t: length of time that all LEDs will be illuminated in MILLISECONDS */ void all_on( unsigned long all_t ) { unsigned long start = millis(); int flag = 1; while( flag ) { for( int row = 1; row &amp;lt; 7; row++) { for( int col = 1; col &amp;lt; 7; col++) { led_pulse( row, col, 20 ); if( millis() - start &amp;gt; all_t ) flag = 0; } } } } The all_on() function behaves exactly as named. It illuminates all of the LEDs in the 6√ó6 matrix for a specified amount of time. Again, this function takes its argument in milliseconds. And there is yet again a different method for keeping track of time. This one is quite similar to the previous method in that it checks the runtime of the method against the requested time. But, in this case, the check is performed after every single pulse of a single LED. To do this, a flag integer is used to check that the runtime is still less than the requested time. All of the LED pulsing happens within a while loop, so when the correct amount of time has elapsed, the flag is simply set to 0, or false, and the while loop exits along with the function. And, in order to flash all LEDs in the matrix one after another, two for loops run through each row and each column, lighting all the LEDs along the way. This time, 20 microseconds is used as the ‚Äòon‚Äô time for led_pulse(). /* * Function: zig_rows * -------------------- * Illuminates rows one by one, in a back and forth pattern. * This starts with row 1, progreses to row 6, then ends back at row 2 * * repeat: number of times that the pattern will be repeated * row_t: length of time that each individual row will be illuminated in MILLISECONDS */ void zig_rows( int repeat, unsigned long row_t ) { while( repeat ) { for( unsigned long i = 2345654321; i &amp;gt; 0; i = i / 10 ) row_pulse( i % 10, row_t ); repeat--; } } /* * Function: zig_cols * -------------------- * Illuminates columns one by one, in a back and forth pattern. * This starts with column 1, progreses to column 6, then ends back at column 2 * * repeat: number of times that the pattern will be repeated * col_t: length of time that each individual column will be illuminated in MILLISECONDS */ void zig_cols( int repeat, unsigned long col_t ) { while( repeat ) { for( unsigned long i = 2345654321; i &amp;gt; 0; i = i / 10 ) col_pulse( i % 10, col_t ); repeat--; } } I like these functions quite a lot. They are for creating a certain pattern using the row and column pulse functions. The for loop might look a little strange, but it‚Äôs nothing crazy. I start with a counter integer 2345654321. On the first pass of the loop, either row or col_pulse is called. If we take zig_rows(), for example, the row that is called is i % 10. By using modulo ten, we are calculating the remainder of a number divided by ten. And anything divided by ten gives a remainder of whatever was in that number‚Äôs one‚Äôs place. This means that the row that is pulsed corresponds to the one‚Äôs place of our counter integer i. On the first pass, it would be 1, since 1 is in the one‚Äôs place of 2345654321. Our loop then divides the counter by 10. Since it is integer division, this just chops off the current digit in the one‚Äôs place. The counter is now 234565432. This repeats until i is divided away to 0, meaning that each row is called in a back and forth pattern (rows 1, 2, 3, 4, 5, 6, then 5, 4, 3, and finally 2 again). You‚Äôll also note that the counter i is of the data type unsigned long. That‚Äôs because it is such a large number, we need a large data type to hold it. This entire process is enclosed in a while loop that also has a counter that is decrementing. It uses the repeat argument that is passed to the function in order to loop the pattern for the requested number of times. The function also takes an argument that it uses in either the col_pulse() or row_pulse() function for the length of time each row or column should be lit for. Note that this value is in milliseconds. /* * Function: led_rand * -------------------- * Illuminates a specified number of random LEDs in the matrix, each for a specified amount of time * * repeat: number of LEDs to be illuminated, one after another * t: length of time that the random LED will be illuminated in MILLISECONDS */ void led_rand( int repeat, unsigned long t ) { while( repeat ) { led_pulse( random( 1, 7 ), random( 1, 7 ), t * 1000 ); repeat--; } } This is my favorite function. It makes use of the random seed that we created earlier in order to flash a random LED in the matrix. Its arguments are repeat and t. Just like the last two functions, repeat is how many times the pattern should repeat. And in this case, the pattern is just picking a random LED to pulse. t is how long each random LED should be illuminated. Notice that this function also takes its time argument in milliseconds. However, the led_pulse() function takes its time in microseconds. In order to convert, we simply multiply by 1000 before calling led_pulse(). In order to pick a random LED, random() is used with two arguments. 1 is given as a minimum value (inclusive), and 7 is given as a maximum value (exclusive). void loop() { zig_rows( 2, 200 ); all_on( 500 ); led_rand( 20, 200 ); all_on( 500 ); zig_cols( 2, 200 ); all_on( 500 ); led_rand( 20, 200 ); all_on( 500 ); } Finally, we finish up with the actual Arduino loop() function! All it consists of is calling some of our created functions with appropriate values. Play around with these values to see how it changes the patterns and timings! You could also change the ‚Äòon‚Äô time values in the row_pulse(), col_pulse(), and all_on() functions in order to experiment with different values than 10 and 20 microseconds when calling led_pulse(). Have fun! -Troy</summary></entry><entry><title type="html">Microchip MMD Register Tool</title><link href="http://localhost:4000/blog/2020/07/11/Microchip-MMD-Register-Tool/" rel="alternate" type="text/html" title="Microchip MMD Register Tool" /><published>2020-07-11T17:23:00-04:00</published><updated>2020-07-11T17:23:00-04:00</updated><id>http://localhost:4000/blog/2020/07/11/Microchip-MMD-Register-Tool</id><content type="html" xml:base="http://localhost:4000/blog/2020/07/11/Microchip-MMD-Register-Tool/">&lt;p&gt;Recently I have been working with Microchip‚Äôs KSZ9896C Gigabit Ethernet Switch in a board design (datasheet found &lt;strong&gt;&lt;a href=&quot;https://www.microchip.com/wwwproducts/en/KSZ9896&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;). When the switch is handling packets between two computers on two of its ports, it seems to function fine. Good news for my engineering as far as the schematic and impedance control, so that‚Äôs a relief! However, the board actually has multiple interconnected switches to increase the number of available ports available externally. When I connect to one switch and try to send traffic to a computer on another switch, I get nothing. Well, nothing works perfectly the first time, right?&lt;/p&gt;

&lt;p&gt;In my quest for some answers and a solution (Turns out it was a speed auto-negotiation problem between ethernet ports!), my googling took me to this Texas Instruments forum post:
&lt;a href=&quot;https://e2e.ti.com/support/interface/f/138/t/821181&quot;&gt;https://e2e.ti.com/support/interface/f/138/t/821181&lt;/a&gt;.
The resolution to the problem might be applying all patches outlined in the errata document for the KSZ9896C. After reviewing it, I figured that the solutions proposed in the document should be applied to my switches anyways, regardless if they solved my issues.&lt;/p&gt;

&lt;p&gt;As of me writing this, the errata document outlines 14 identified issues and offers solutions for most of them (check out that document &lt;strong&gt;&lt;a href=&quot;http://ww1.microchip.com/downloads/en/DeviceDoc/80000757C.pdf&quot;&gt;here&lt;/a&gt;&lt;/strong&gt;). Of these solutions, many involve simply changing some register values. In my case, I am managing the switch and changing these registers over the SPI interface. Performing reads and writes is relatively easy given an address and data. I‚Äôve included a picture below that shows the format that SPI data should be in for reads and writes. This is given in the datasheet starting on page 53.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/microchip-mmd-register-tool-01.png&quot; alt=&quot;SPI data format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The difficulty with quite a few of the errata fixes arises from the fact that they deal with MMD registers. These are indirect registers that are not directly accessible, and require a bit more work to read and write to. In fact, the only way to interact with these special registers is through two ‚Äòportal registers‚Äô that are in the regular address space. page 167 of the KSZ9896C data sheet goes into detail about the process to access the MMD registers, as well as some examples.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/microchip-mmd-register-tool-02.png&quot; alt=&quot;MMD register examples&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In order to actually apply these errata fixes then, it is necessary to translate quite a few mmd register writes into a usable SPI transmittable form. Microchip did not have the data in this format readily on hand, so I have decided to create a quick C program that takes in a file listing the mmd register addresses and data, and spits out a vhdl file holding all the binary data in an array. I do this simply becuase I am communicating with my switches through the use of an onboard FPGA. Hopefully you find this tool useful!&lt;/p&gt;

&lt;p&gt;I‚Äôve made a repo for the program that you can find here:
&lt;a href=&quot;https://github.com/troy-pallay/uchip-mmd-register-tool&quot;&gt;https://github.com/troy-pallay/uchip-mmd-register-tool&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;-Troy&lt;/p&gt;</content><author><name>Troy Pallay</name></author><summary type="html">Recently I have been working with Microchip‚Äôs KSZ9896C Gigabit Ethernet Switch in a board design (datasheet found here). When the switch is handling packets between two computers on two of its ports, it seems to function fine. Good news for my engineering as far as the schematic and impedance control, so that‚Äôs a relief! However, the board actually has multiple interconnected switches to increase the number of available ports available externally. When I connect to one switch and try to send traffic to a computer on another switch, I get nothing. Well, nothing works perfectly the first time, right?</summary></entry></feed>